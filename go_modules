#!/usr/bin/env python3
#
# An OBS Source Service to retrieve and verify Go module sources
# as specified in go.mod and go.sum.
#
# (C) 2019 SUSE LLC
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# See http://www.gnu.org/licenses/gpl-2.0.html for full license text.
#
"""\
# OBS Source Service `obs-service-go_modules`

An OBS Source Service to download, verify and vendor Go module 
dependency sources.

Using go.mod and go.sum present in a Go application, call
go tools in sequence:

```
go mod download
go mod verify
go mod vendor
```

`obs-service-go_modules` will create `vendor.tar.gz` containing the
`vendor/` directory populated by `go mod vendor`. `vendor.tar.gz`
is generated in the rpm package directory.

## Usage for packagers

Presently it is assumed the Go application is distributed as
a tarball `app-0.1.0.tar.gz` unpacking to `app-0.1.0/`

Create a _services file containing:

```
<services>
  <service name="go_modules" mode="disabled">
    <param name="archive">app-0.1.0.tar.gz</param>
  </service>
</services>
```

Run osc command locally:

```
osc service disabledrun
```

## Transition note

Until such time as obs-service-go_modules is available on
OBS, `vendor.tar.gz should be committed along with the
Go application release tarball.
"""

import logging
import argparse
import tarfile
import os
import shutil

from subprocess import check_output
from subprocess import CalledProcessError

app_name = "obs-service-go_modules"
vendor_tarname = "vendor.tar.gz"

description = __doc__

logging.basicConfig(level=logging.DEBUG)
log = logging.getLogger(app_name)

parser = argparse.ArgumentParser(
    description=description, formatter_class=argparse.RawDescriptionHelpFormatter
)
parser.add_argument("--strategy", default="vendor")
parser.add_argument("--archive")
parser.add_argument("--outdir")
args = parser.parse_args()


outdir = args.outdir
archive = args.archive
basename = archive.replace(".tar.gz", "")  # currently only .tar.gz supported


def extract(filename, dir):
    if filename.endswith(".tar.gz"):
        tar = tarfile.open(filename)
        tar.extractall(path=dir)
        tar.close()
    else:
        log.info(f"Unsupported archive file format for {filename}")
        exit(1)


def find_file(path, filename):
    for root, dirs, files in os.walk(path):
        if filename in files:
            return os.path.join(root, filename)


def cmd_go_mod(cmd, dir):
    try:
        log.info(f"go mod {cmd}")
        output = check_output(["go", "mod", cmd], cwd=dir).decode("utf-8").strip()
        if output:
            log.info(output)
        return True
    except CalledProcessError as e:
        error = e.output.decode("utf-8").strip()
        if error:
            log.info(error)
        return False


def main():
    log.info(f"Running OBS Source Service: {app_name}")

    log.info(f"Extracting {archive} to {outdir}")
    extract(archive, outdir)

    go_mod_path = find_file(outdir, "go.mod")
    if go_mod_path:
        go_mod_dir = os.path.dirname(go_mod_path)
        log.info(f"Using go.mod found at {go_mod_path}")
    else:
        log.info(f"File go.mod not found under {outdir}")
        exit(1)

    if args.strategy == "vendor":

        cmd_go_mod("download", go_mod_dir)
        cmd_go_mod("verify", go_mod_dir)
        cmd_go_mod("vendor", go_mod_dir)

        log.info(f"Vendor go.mod dependencies to {vendor_tarname}")
        vendor_tarfile = os.path.join(outdir, vendor_tarname)
        vendor_dir = os.path.join(go_mod_dir, "vendor")
        with tarfile.open(vendor_tarfile, "w:gz") as tar:
            tar.add(vendor_dir, arcname=("vendor"))

        # remove extracted Go application source
        shutil.rmtree(os.path.join(outdir, basename))


if __name__ == "__main__":
    main()
